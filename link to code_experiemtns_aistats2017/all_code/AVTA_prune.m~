function [k_index,all_alpha,err]=AVTA_prune(Q_bar,K,proj_dim,gamma)
tic
%% compute a super set of vertices

[NN MM]=size(Q_bar);
ori_Q=Q_bar;
dim_project=proj_dim;
rand_matrix=random('Normal',0,1,MM,dim_project);

projected_Q=Q_bar*rand_matrix;
Q_bar=projected_Q;
Qmat=Q_bar;

index_set=[];


epsilon=2;

eudis=sum(Q_bar.*Q_bar,2);
tmparr=find(eudis==max(eudis));
max_index=tmparr(1);


index_set=logical(zeros(1,NN));
vtx_ind_1=max_index;

index_set(vtx_ind_1)=1;

S_set=logical(ones(1,NN));
candidate_set=S_set;
candidate_set(index_set)=0;
index_series=1:NN;
alpha_zero=ones(sum(index_set),NN);

pre_index=index_set;
%disp('start computing vertices')
while epsilon>gamma || sum(index_set)<K
    S_set=logical(ones(1,NN));
    %S_set(index_set)=1;
    candidate_set=S_set;
    candidate_set(index_set)=0;
    
    if sum(index_set)>=K
        break;
    end
    %disp(['number of vtx of convex hull is ' num2str(sum(index_set))]);
    while sum(candidate_set)>0
        current_index=index_series(candidate_set);
        current_size=length(current_index);
        rnd_ind=unidrnd(current_size,1,1); 
        this_index=current_index(rnd_ind);
        this_data=Q_bar(index_set,:)';
        p=Q_bar(this_index,:)';
        [inorout,p_prime,alpha_coe,dist]=anti_ta_warm(this_data,p,epsilon,alpha_zero(:,this_index));
        if inorout==1 
            candidate_set(this_index)=0;
            alpha_zero(:,this_index)=alpha_coe';
        else



            direction=p_prime-p;
            S_index=index_series(candidate_set);
            S_data=Qmat(S_index,:);

            projected_val=S_data*direction;
            index_2=min(find(projected_val==min(projected_val)));
            index_candidate_2=S_index(index_2);
            candidate_set(index_candidate_2)=0;
            
            if index_set(index_candidate_2)==0
                index_set(index_candidate_2)=1;
                
                
                [kk NN]=size(alpha_zero);
                if length(index_series(index_set))~=kk && sum(pre_index)~=0
                    pre_series=index_series(pre_index);
                    now_index_set=index_series(index_set);
                    [tmp_srt,tmp_idx]=sort([pre_series,setdiff(now_index_set,pre_series)]);

                    tmp_al=alpha_zero;
                    alpha_zero=zeros(length( now_index_set),NN);
                    num_new=length(setdiff(now_index_set,pre_series));

                    alpha_zero(1:(end-num_new),:)=tmp_al;
                    alpha_zero=alpha_zero(tmp_idx,:);
                    pre_index=index_set;

                end
                
            end

        end
    end
    %epsilon
    epsilon=epsilon*0.95;
end

%disp('finish compute vertices')

super_index=index_series(index_set);
%disp(['number of vertices before prune is ' num2str(length(super_index))]);
superset_data=ori_Q(super_index,:)';

%% pruning 
if length(super_index)>K
    %disp('start prune');
    [NN MM]=size(superset_data);
    index_set=logical(ones(1,MM));
    index_series=1:MM;
    while sum(index_set)>K
        %disp(['current number of vertices is ' num2str(sum(index_set))])
        current_indexset=index_series(index_set);
        dist_vtx=zeros(1,length(current_indexset));
        
        for i=1:length(current_indexset)
            p=superset_data(:,current_indexset(i));
            tmp_ind=setdiff(current_indexset,current_indexset(i));
            current_cols=superset_data(:,tmp_ind);
            [alp dis]=frank_wolfe_2(p, current_cols, 0.001);
            dist_vtx(i)=dis;
        end
        min_dist_index=min(find(dist_vtx==min(dist_vtx)));
        index_set(current_indexset(min_dist_index))=0;
    end
    k_index=index_series(index_set);
    %disp('finish prune');
else
    k_index=super_index;
end
% 
%% compute alpha
%disp('start computing alpha');

all_alpha=zeros(K,size(Q_bar,1));
vtx_data=Q_bar(k_index,:)';
dis_vec=zeros(1,size(Q_bar,1));
for i=1:size(Q_bar,1)
    p=Q_bar(i,:)';
    [alp dis]=frank_wolfe_2(p, vtx_data, 0.01);
    all_alpha(:,i)=alp;
    dis_vec(i)=dis;
    %i
end
toc
err=mean(dis_vec);
%disp('finish computing alpha');
    




